import secrets
import socket
import random
import uuid
import os

import tomlkit

from .. import utils, Wallet


# TODO: Re-write WalletsDatabase to use sqlite with peewee package
#       - create Wallet model to keep track of wallet names, paths, addresses, API ports, etc
# TODO: Update nodeJS epicbox code to send notifications
#       - use simple post requests to the given url address
# TODO: Write webhook server that receives epicbox notifications and calls wallet's api
#       -

class WalletsDatabase:
    def __init__(self, wallets_dir: str):
        self.wallets_dir = wallets_dir
        self.file_info = f"# EPIC PythonSDK - autogenerated file, do not edit.\n\n"

        if not os.path.exists(self.wallets_dir):
            os.mkdir(self.wallets_dir)
            self.file = os.path.join(self.wallets_dir, 'wallets.toml')

            with open(self.file, 'w') as file:
                file.write(self.file_info)
        else:
            self.file = os.path.join(self.wallets_dir, 'wallets.toml')

    def _read(self):
        with open(self.file, "r") as file:
            return tomlkit.load(file)

    def _save(self, data):
        with open(self.file, 'w+') as file:
            tomlkit.dump(data, file)

    def add(self, wallet: Wallet):
        data = self._read()
        data[wallet.config.name] = wallet.config.wallet_data_directory
        self._save(data)

    def get_wallet(self, wallet_name: str) -> str | None:
        data = self._read()

        if wallet_name in data:
            return data[wallet_name]
        else:
            return None

    def get_wallets(self, wallet_names: list[str] = None) -> list[str]:
        data = self._read()

        if wallet_names:
            return [data[wallet_name] for wallet_name in wallet_names if wallet_name in data]
        else:
            return [data[wallet_name] for wallet_name in data]


class Manager:
    """
    Manage multiple wallet instances
    - create new wallets, manage api ports, wallet dirs
    """
    ports_range = (5000, 60000)

    def __init__(self, wallets_dir: str, binary_path: str):
        self.wallets_dir = wallets_dir
        self.binary_path = binary_path
        self.wallets_db = WalletsDatabase(self.wallets_dir)

    async def create_batch(self, wallets_args: list[dict] = None, num: int = None):
        if not num and wallets_args:
            num = len(wallets_args)

        for i in range(num):
            id_ = str(uuid.uuid4())
            name = f"wallet_{id_}"

            args = {
                'id': id_,
                'name': name,
                'debug': True,
                'password': secrets.token_urlsafe(32),
                'node_address': utils.defaults.PUBLIC_NODE,
                'epicbox_domain': utils.defaults.EPICBOX_NODE,
                'binary_file_path': self.binary_path,
                'owner_api_listen_port': self._get_random_port(),
                }

            if wallets_args:
                args.update(wallets_args[i])
                if 'wallet_data_directory' not in args:
                    args['wallet_data_directory'] = os.path.join(self.wallets_dir, args['name'])

            response = await Wallet().create_new(**args)

            if response['error']:
                utils.logger.error(response)
            else:
                self.wallets_db.add(response['data'])

        return [Wallet(path) for path in self.wallets_db.get_wallets(wallet_names=[w['name'] for w in wallets_args])]

    def get_wallets(self, wallet_names: list[str] = None):
        return [Wallet(path) for path in self.wallets_db.get_wallets(wallet_names)]

    @staticmethod
    def _is_port_in_use(port: int) -> bool:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(('localhost', port)) == 0

    def _get_random_port(self):
        port_ = random.randint(self.ports_range[0], self.ports_range[1])

        while self._is_port_in_use(port_):
            port_ = random.randint(self.ports_range[0], self.ports_range[1])

        return port_
